# -*- coding: utf-8 -*-
"""소음분석_230118

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ooBteegONynmMMwPtGHCVnPCUW_q3Gta
"""

#This code predicts sound levels in



!pip install pyproj

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import torch.nn as nn
import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt
import pandas as pd
from pandas import DataFrame
import time
from pyproj import Proj, transform
# %matplotlib inline

def main():

    raw_data = pd.read_csv('./civil/20210819_noise.csv', encoding = 'cp949', skiprows = 1).to_numpy()

    data = process_data(raw_data)
    print(data)
#end of def main

def process_data(raw_data):
    col_list = []
    for i in range(raw_data.shape[1]):
        if i % 4 == 0:
            col_list.append(i)
        #end of if
    #end of for
    data = np.delete(raw_data, col_list, 1).astype('float64') 
    origin1 = [38.115769, 127.087267]
    origin2 = [38.116613, 127.087116]
    sensor1_loc = np.zeros([180,2])
    sensor2_loc = np.zeros([180,2])
    sensor1_loc[:,0].fill(origin1[0])
    sensor1_loc[:,1].fill(origin1[1])
    sensor2_loc[:,0].fill(origin2[0])
    sensor2_loc[: ,1].fill(origin2[1])

    raw_data[:,360:362] = sensor1_loc
    raw_data[:,363:365] = sensor2_loc
    return data
#end of def process_data
#test에 쓸 센서 찾기

location = []
for index, i in enumerate(raw_data[1,:]):
  if index % 3 != 2:
    location.append(i)

location = np.array(location)

sensor_loc = location[0:240]
sound1_loc = location[240:242]
sound2_loc = location[242:244]

#소음원1,2에 가장 가까운 센서 찾기
#네 귀퉁이에 가장 가까운 센서 찾기
p1 = [0.00525+3.811*10,0.0007+1.27087*100]
p2 = [0.00525+3.811*10,0.00+1.27087*100]
p3 = [0.00725+3.811*10,0.00+1.27087*100]
p4 = [0.00725+3.811*10,0.0007+1.27087*100]
distance_from_sound1 = []
distance_from_sound2 = []
dist_from_p1 = []
dist_from_p2 = []
dist_from_p3 = []
dist_from_p4 = []
index = 0
for i in range(120):
  dist1 = ((sensor_loc[index]-sound1_loc[0])**2 + (sensor_loc[index+1]-sound1_loc[1])**2) ** 0.5
  dist2 = ((sensor_loc[index]-sound2_loc[0])**2 + (sensor_loc[index+1]-sound2_loc[1])**2) ** 0.5
  distp1 = ((sensor_loc[index]-p1[0])**2 + (sensor_loc[index+1]-p1[1])**2) 
  distp2 = ((sensor_loc[index]-p2[0])**2 + (sensor_loc[index+1]-p2[1])**2) 
  distp3 = ((sensor_loc[index]-p3[0])**2 + (sensor_loc[index+1]-p3[1])**2) 
  distp4 = ((sensor_loc[index]-p4[0])**2 + (sensor_loc[index+1]-p4[1])**2) 
  
  distance_from_sound1.append(dist1)
  distance_from_sound2.append(dist2)
  dist_from_p1.append(distp1)
  dist_from_p2.append(distp2)
  dist_from_p3.append(distp3)
  dist_from_p4.append(distp4)

  index = index + 2
distance_from_sound1 = np.array(distance_from_sound1)
distance_from_sound2 = np.array(distance_from_sound2)
dist_from_p1 = np.array(dist_from_p1)
dist_from_p2 = np.array(dist_from_p2)
dist_from_p3 = np.array(dist_from_p3)
dist_from_p4 = np.array(dist_from_p4)

print("소음원1에 가장 가까운 센서 index: ", np.argmin(distance_from_sound1))
print("소음원2에 가장 가까운 센서 index: ", np.argmin(distance_from_sound2))
print("p1에 가장 가까운 센서 index: ", np.argmin(dist_from_p1))
print("p2에 가장 가까운 센서 index: ", np.argmin(dist_from_p2))
print("p3에 가장 가까운 센서 index: ", np.argmin(dist_from_p3))
print("p4에 가장 가까운 센서 index: ", np.argmin(dist_from_p4))

input_sensors = np.array([0,5,114,119])
new_sensor = np.array([92,33], dtype = 'int32')
input_sensors = np.append(input_sensors,new_sensor)
origin = np.array([120,121])
input_index = np.append(input_sensors, origin)
input_index
input_sensors

import math
longitude = []
latitude = []
decibel = []

for i in range(len(raw_data[0])):
  if i % 3 == 0:
    latitude.append(raw_data[:,i])
  elif i% 3 == 1:
    longitude.append(raw_data[:,i])
  else:
    decibel.append(raw_data[:,i])

longitude = np.transpose(np.array(longitude))
latitude = np.transpose(np.array(latitude))
decibel = np.transpose(np.array(decibel))

print("Size: ", longitude.shape)

proj_UTMK = Proj(init='epsg:5178')
proj_WGS84 = Proj(init = 'epsg:4326')

def utmk(long,lat):
  fx, fy = transform(proj_WGS84,proj_UTMK, long, lat)
  return np.dstack([fx,fy])[0]

u_coor = utmk(longitude, latitude)
longitude = u_coor[:,0]
latitude = u_coor[:,1]

x = np.max(longitude) - np.min(longitude)
y = np.max(latitude) - np.min(latitude)
print(y/x)

xmin = np.min(longitude)
xmax = np.max(longitude)
ymin = np.min(latitude)
ymax = np.max(latitude)

xavg = (xmin+xmax)/2
y1 = (ymin + 3 * ymax)/4
y2 = (3*ymin + ymax) / 4
print(y1,y2)

cal_s1 = (longitude - xavg) ** 2 + (latitude - y1) ** 2
cal_s2 = (longitude - xavg) ** 2 + (latitude - y2) ** 2
print(np.argmin(cal_s1))
print(np.argmin(cal_s2))

gijun = [1,0]
def cal_degree1(lon,lat):
  vec = [lon-origin1_lon, lat-origin1_lat]
  degree = np.degrees(np.arccos(np.dot(vec,gijun) / np.sqrt(np.dot(vec,vec))))
  if vec[1]<0:
    degree = 360-degree
  return degree

def cal_degree2(lon,lat):
  vec = [lon-origin2_lon, lat-origin2_lat]
  degree = np.degrees(np.arccos(np.dot(vec,gijun) / np.sqrt(np.dot(vec,vec))))
  if vec[1]<0:
    degree = 360-degree
  return degree

#origin data 분류
origin1_lon = longitude[origin[0]]
origin2_lon = longitude[origin[1]]
origin1_lat = latitude[origin[0]]
origin2_lat = latitude[origin[1]]
origin1_dec = decibel[:,origin[0]]
origin2_dec = decibel[:, origin[1]]
# input_data 분류
input_lon = longitude[input_sensors]
input_lat = latitude[input_sensors]
input_dec = decibel[:,input_sensors]
#output_data
output_dec = decibel[:,np.setdiff1d(np.arange(122),input_index)]
output_lon = longitude[np.setdiff1d(np.arange(122),input_index)]
output_lat = latitude[np.setdiff1d(np.arange(122),input_index)]
#distance from origins
sound1_dist = [np.linalg.norm(np.array([origin1_lon,origin1_lat]) - [x,y]) for x, y in zip(input_lon,input_lat)]
sound2_dist = [np.linalg.norm(np.array([origin2_lon,origin2_lat]) - [x,y]) for x, y in zip(input_lon,input_lat)]
sound1_dist_out = [np.linalg.norm(np.array([origin1_lon,origin1_lat]) - [x,y]) for x, y in zip(output_lon, output_lat)]
sound2_dist_out = [np.linalg.norm(np.array([origin2_lon,origin2_lat]) - [x,y]) for x, y in zip(output_lon, output_lat)]
#degree from origins
sound1_degree = [cal_degree1(x,y) for x, y in zip(input_lon, input_lat)]
sound2_degree = [cal_degree2(x,y) for x,y in zip(input_lon, input_lat)]
sound1_degree_out = [cal_degree1(x,y) for x, y in zip(output_lon, output_lat)]
sound2_degree_out = [cal_degree2(x,y) for x,y in zip(output_lon, output_lat)]

input_data = np.zeros((180*len(input_sensors),6))
n_input_sensors = len(input_sensors)
for i in range(n_input_sensors):
  input_data[180*i:180*(i+1),0] = origin1_dec
  input_data[180*i:180*(i+1),1] = origin2_dec
  input_data[180*i:180*(i+1),2] = sound1_dist[i]
  input_data[180*i:180*(i+1),3] = sound2_dist[i]
  input_data[180*i:180*(i+1),4] = sound1_degree[i]
  input_data[180*i:180*(i+1),5] = sound2_degree[i]

x_train = input_data

y_train = np.zeros((180*len(input_sensors),1))
for i in range(n_input_sensors):
  y_train[180*i:180*(i+1),0] = input_dec[:,i]
x_length = x_train.shape[1]
y_length = y_train.shape[1]

sec = 180
n_output_sensors = 120-n_input_sensors
x_test = np.zeros((180*n_output_sensors,6))
for i in range(n_output_sensors):
  x_test[sec*i:sec*(i+1),0] = origin1_dec
  x_test[sec*i:sec*(i+1),1] = origin2_dec
  x_test[sec*i:sec*(i+1),2] = 1/(sound1_dist_out[i] ** 2)
  x_test[sec*i:sec*(i+1),3] = 1/(sound2_dist_out[i] ** 2)
  x_test[sec*i:sec*(i+1),4] = sound1_degree_out[i]
  x_test[sec*i:sec*(i+1),5] = sound2_degree_out[i]

y_test = np.zeros((180*n_output_sensors, 1))
for i in range(n_output_sensors):
  y_test[sec*i:sec*(i+1),0] = output_dec[:,i]

import matplotlib.cm as cm
colors = cm.rainbow(np.linspace(0, 1, 20))
mlp_lat = np.transpose(np.reshape(output_lat[:],(1,-1)))
mlp_lon = np.transpose(np.reshape(output_lon[:],(1,-1)))
mlp_dec = np.transpose(np.reshape(output_dec[0,:],(1,-1)))
tot = np.concatenate((mlp_lat,mlp_lon,mlp_dec), axis = 1)
ind=np.argsort(tot[:,-1])
b=tot[ind]
plt.figure(figsize = (1,3.386))
plt.scatter(input_lon[:], input_lat[:], s = 100, color = "black", marker = "X", label = 'Chosen sensors')
plt.scatter(origin1_lon, origin1_lat, s = 100, color = 'm', marker = "D", label = 'dB origin #1')
plt.scatter(origin2_lon, origin2_lat, s = 100, color = 'y', marker = "D", label = 'dB origin #2')
for x,y, dec in zip(b[:,1], b[:,0], b[:,2]):

  if dec >= 90:
    plt.scatter(x,y, c = np.reshape(colors[19,:], (1,-1)))
  elif dec >= 80 and dec < 90:
    plt.scatter(x,y, c = np.reshape(colors[17,:], (1,-1)))
  elif dec >= 70 and dec < 80:
    plt.scatter(x,y, c = np.reshape(colors[15,:], (1,-1)))
  elif dec >= 60 and dec < 70:
    plt.scatter(x,y, c = np.reshape(colors[13,:], (1,-1)))
  elif dec >= 50 and dec < 60:
    plt.scatter(x,y, c = np.reshape(colors[5,:], (1,-1)))
  else:
    plt.scatter(x,y, c = np.reshape(colors[3,:], (1,-1)))
  
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[19,:], (1,-1)), label = '90 < dec')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[17,:], (1,-1)), label = '80 < dec < 90')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[15,:], (1,-1)), label = '70 < dec < 80')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[13,:], (1,-1)), label = '60 < dec < 70')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[5,:], (1,-1)), label = '50 < dec < 60')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[3,:], (1,-1)),  label = 'dec < 50')
# for lat, c in zip(output_lat, colors):
plt.title('Heat map of decibel values')
plt.legend(loc = 'center left', bbox_to_anchor = (1,0.5))

plt.show()

#building model

class LinearRegressionModel(nn.Module):
  def __init__(self):
    super().__init__()
    self.linear1 = nn.Linear(x_length, 16)
    self.linear2 = nn.Linear(16,64)
    self.linear3 = nn.Linear(64,128)
    self.linear4 = nn.Linear(128,128)
    self.linear5 = nn.Linear(128,64)
    self.linear6 = nn.Linear(64,32)
    self.linear7 = nn.Linear(32,16)
    self.linear8 = nn.Linear(16,y_length)
    self.relu = nn.LeakyReLU(0.2)

  def forward(self,x):
    x = self.relu(self.linear1(x))
    x = self.relu(self.linear2(x))
    x = self.relu(self.linear3(x))
    x = self.relu(self.linear4(x))
    x = self.relu(self.linear5(x))
    x = self.relu(self.linear6(x))
    x = self.relu(self.linear7(x))
    x = self.linear8(x)

    return x

x_train.shape[1]

tmp = np.concatenate((x_train,y_train), axis = 1)
np.random.shuffle(tmp)
x_train = tmp[:,0:6]
y_train = tmp[:,6]
y_train

x_train1 = x_train
y_train1 = y_train.reshape(-1,1)
arr = np.concatenate((x_train1,y_train1), axis= 1)
df = pd.DataFrame(arr)
df.to_csv('xy_train.csv', index = False)



from copy import deepcopy
x_train = torch.FloatTensor(x_train)
y_train = torch.FloatTensor(y_train)

x_test = torch.FloatTensor(x_test)
y_test = torch.FloatTensor(y_test)
train_loss = []
validation_loss = []
epochs = []
model = LinearRegressionModel()
optimizer = torch.optim.Adam(model.parameters(), lr=0.0001, weight_decay = 0.01)
nb_epochs = 2000
best_acc = 0
best_acc_model = None
for epoch in range(nb_epochs+1):
    
    torch.autograd.set_detect_anomaly(True)

    # H(x) 계산
    prediction = model(x_train)
    # model(x_train)은 model.forward(x_train)와 동일함.
    

    # cost 계산
    cost = F.mse_loss(prediction, y_train) # <== 파이토치에서 제공하는 평균 제곱 오차 함수

    # cost로 H(x) 개선하는 부분
    # gradient를 0으로 초기화
    optimizer.zero_grad()
    # 비용 함수를 미분하여 gradient 계산
    cost.backward()
    # W와 b를 업데이트
    optimizer.step()

    train_loss.append(cost)
    epochs.append(epoch)
    with torch.no_grad():
      val_loss = F.mse_loss(model(x_test), y_test)
      validation_loss.append(val_loss)
      y_pred = np.array(model(x_test))
      acc_epoch = np.mean(100 * (1 - np.abs((y_pred - np.array(y_test)))/np.array(y_test)))
      if acc_epoch > best_acc:
        print('Best model found at epoch: ', epoch, 'with accuracy = ', acc_epoch)
        best_acc = acc_epoch
        best_acc_model = deepcopy(model.state_dict()) 
      
      

    if epoch % 100 == 0:
      print('epoch:', epoch, 'train loss:', cost.item(), "validation loss: ", val_loss.item())

      

print("분석 끝")

PATH = '/content/model.pth'
torch.save(best_acc_model, PATH)

plt.plot(epochs, accuracy)
plt.title("Accuracy increase with epoch")
plt.xlabel()

max(y_test)

with torch.no_grad():
  plt.plot(epochs, train_loss, label = 'Train Loss')
  plt.plot(epochs, validation_loss, label= "Validation Loss")
  plt.scatter(epochs[1474], validation_loss[1474], label = "Early Stopping ", marker = "X", color = 'black')
  plt.legend()
  plt.xlabel("Epoch")
  plt.ylabel('Loss')
  plt.title('MSE Loss per epoch')
  plt.show()

with torch.no_grad():
  e1 = np.reshape(np.array(epochs), (-1,1))
  e2 = np.reshape(np.array(train_loss), (-1,1))
  e3 = np.reshape(np.array(validation_loss), (-1,1))

arr = np.concatenate((e1,e2,e3), axis = 1)
arr
df = pd.DataFrame(arr)
df.to_csv('sample.csv', index=False)

model1 = LinearRegressionModel()
model1.load_state_dict(torch.load(PATH))

with torch.no_grad():
  y_pred = model1(x_test)
  accuracy = []
  for i in range(n_output_sensors*sec):

    accuracy.append(100*(1- (np.abs((np.array(y_pred[i,0])-np.array(y_test[i,0]))/np.array(y_test[i,0])))))

accuracy_per_sensor = []

for i in range(n_output_sensors):
  x=[]
  x = np.sum(accuracy[i*sec:(i+1)*sec])
  x = x/(sec)
  accuracy_per_sensor.append(x)


accuracy_per_sensor = np.array(accuracy_per_sensor)
print("maximum accuracy: ", np.max(accuracy_per_sensor), 'at output sensor number ', np.argmax(accuracy_per_sensor))
print('mimimum accuracy: ', np.min(accuracy_per_sensor), 'at output sensor number ', np.argmin(accuracy_per_sensor))
print('average accuracy: ', np.mean(accuracy_per_sensor))
min_sen = np.argmin(accuracy_per_sensor)
lat_sensor_to_add = output_lat[np.argmin(accuracy_per_sensor)]
num_sensor_to_add = np.where(latitude == lat_sensor_to_add)
print("sensor number to add at next step: ", num_sensor_to_add)

soo = np.array(np.abs(y_test-y_pred))
np.argmax(soo)/180
y_pred.shape

y_pred1 = np.array(y_pred).reshape(-1)
y_test1 = np.array(y_test).reshape(-1)

y_pred_p = []
y_test_p = []
for i in range(114):
  y_pred_p.append(np.mean(y_pred1[i*sec:(i+1)*sec]))
  y_test_p.append(np.mean(y_test1[i*sec:(i+1)*sec]))
plt.xlim(50,80)
plt.ylim(50,80)
y_pred_p = np.array(y_pred_p)
y_test_p = np.array(y_test_p)
plt.scatter(y_test_p, y_pred_p)
plt.show()

x = np.arange(114) + 1
plt.plot(x, accuracy_per_sensor)
plt.ylim(0,100)
plt.show()

colors = cm.rainbow(np.linspace(0, 1, 20))
mlp_lat = np.transpose(np.reshape(output_lat[:],(1,-1)))
mlp_lon = np.transpose(np.reshape(output_lon[:],(1,-1)))
mlp_acc = np.transpose(np.reshape(accuracy_per_sensor,(1,-1)))
tot = np.concatenate((mlp_lat,mlp_lon,mlp_acc), axis = 1)

ind=np.argsort(tot[:,-1])
b=tot[ind]
plt.figure(figsize = (1,4))
plt.scatter(input_lon[:], input_lat[:], s = 100, color = "black", marker = "X", label = 'Chosen sensors')
plt.scatter(origin1_lon, origin1_lat, s = 100, color = 'm', marker = "D", label = 'dB origin #1')
plt.scatter(origin2_lon, origin2_lat, s = 100, color = 'y', marker = "D", label = 'dB origin #2')

for x,y, acc in zip(b[:,1], b[:,0], b[:,2]):

  if acc >= 95:
    plt.scatter(x,y, c = np.reshape(colors[19,:], (1,-1)))
  elif acc >= 90 and acc < 95:
    plt.scatter(x,y, c = np.reshape(colors[17,:], (1,-1)))
  elif acc >= 85 and acc < 90:
    plt.scatter(x,y, c = np.reshape(colors[15,:], (1,-1)))
  elif acc >= 80 and acc < 85:
    plt.scatter(x,y, c = np.reshape(colors[13,:], (1,-1)))
  elif acc >= 75 and acc < 80:
    plt.scatter(x,y, c = np.reshape(colors[11,:], (1,-1)))
  else:
    plt.scatter(x,y, c = np.reshape(colors[9,:], (1,-1)))

plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[19,:], (1,-1)),  label = '95 < acc')  
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[17,:], (1,-1)), label = '90 < acc < 95')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[15,:], (1,-1)), label = '85 < acc < 90')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[13,:], (1,-1)), label = '80 < acc < 85')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[11,:], (1,-1)), label = '75 < acc < 80')
plt.scatter(np.NaN, np.NaN,  c = np.reshape(colors[9,:], (1,-1)), label = 'acc < 75')

#plt.scatter(output_lon[min_sen], output_lat[min_sen], s =200, label = "Sensor with minimum accuracy")
# for lat, c in zip(output_lat, colors):

plt.title('Heat map of accuracy', pad = 20)
plt.legend(loc = 'center left', bbox_to_anchor = (1,0.5))
plt.xlabel("UTM-K coordinates", labelpad = 20)
plt.show()
if __name__ == '__main__':
    main()
        
